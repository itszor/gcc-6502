(define_attr "arch"
  "any,n02,n02x,nmos,wc02,wsc02,huc,cmos,phx,no_phx"
  (const_string "any"))

(define_attr "arch_enabled" "no,yes"
  (cond [(eq_attr "arch" "any")
	 (const_string "yes")
	 
	 (and (eq_attr "arch" "n02")
	      (match_test "TARGET_6502"))
	 (const_string "yes")

	 (and (eq_attr "arch" "n02x")
	      (match_test "TARGET_6502X"))
	 (const_string "yes")

	 (and (eq_attr "arch" "nmos")
	      (match_test "TARGET_NMOS"))
	 (const_string "yes")

	 (and (eq_attr "arch" "wc02")
	      (match_test "TARGET_65C02"))
	 (const_string "yes")

	 (and (eq_attr "arch" "wsc02")
	      (match_test "TARGET_65SC02"))
	 (const_string "yes")

	 (and (eq_attr "arch" "huc")
	      (match_test "TARGET_HUC6280"))
	 (const_string "yes")

	 (and (eq_attr "arch" "cmos")
	      (match_test "TARGET_CMOS"))
	 (const_string "yes")

	 (and (eq_attr "arch" "phx")
	      (match_test "TARGET_PHX"))
	 (const_string "yes")

	 (and (eq_attr "arch" "no_phx")
	      (match_test "!TARGET_PHX"))
	 (const_string "yes")]
	
	(const_string "no")))

(define_attr "enabled" "no,yes"
  (cond [(eq_attr "arch_enabled" "no")
	 (const_string "no")]
	(const_string "yes")))

(define_constants
  [(ACC_REGNUM 0)
   (X_REGNUM 4)
   (Y_REGNUM 8)
   (NZ_REGNUM 68)
   (CARRY_REGNUM 72)
   (OVERFLOW_REGNUM 76)
   (HARDSP_REGNUM 80)
   (TMP0_REGNUM 82)
   (TMP1_REGNUM 83)])

(define_c_enum "unspec" [
  UNSPEC_SBC_NZ		; NZ flag as set from SBC instruction.
  UNSPEC_SBC_OVF	; Overflow flag as set from SBC instruction.
  UNSPEC_NEG_HIBIT	; An eor #$80 setting overflow/negative bits.
  UNSPEC_IOR_CC		; An inclusive-or setting negative/zero bits.
  UNSPEC_ADC_C		; Carry-setting part of add-with-carry.
  UNSPEC_SBC_C		; Carry-setting part of subtract-with-carry.
  UNSPEC_ASL_C		; Carry-setting part of asl.
  UNSPEC_LSR_C		; Carry-setting part of lsr.
  UNSPEC_INCDEC_NZ	; NZ-setting part of inc or dec.
  UNSPEC_LOAD_NZ	; NZ-setting part of load.
  UNSPEC_ROR		; 9-bit rotate right through carry.
  UNSPEC_ROL		; 9-bit rotate left through carry.
  UNSPEC_LOADQI
  UNSPEC_STOREQI
  UNSPEC_MOVZP
  UNSPEC_MOVZP_CLOB
  UNSPEC_FLAGS
  UNSPEC_FLAGS_NZ
  UNSPEC_FLAGS_C
  UNSPEC_FLAGS_V
  UNSPEC_XIND		; Indexed indirect addressing.
  UNSPEC_CLC
  UNSPEC_SEC
])

(define_c_enum "unspecv" [
  UNSPECV_SAVESTACK_S7S0_SP
  UNSPECV_RESTORESTACK_S7S0_SP_RTS
  UNSPECV_SAVESTACK_S7S0
  UNSPECV_RESTORESTACK_S7S0_RTS
])

; There isn't really a sane default length for an instruction. Pick 2 (bytes).
(define_attr "length" ""
  (const_int 2))

(include "constraints.md")
(include "predicates.md")

; HImode/SImode operations.

(define_mode_iterator HISI [HI SI])

(define_expand "mov<mode>"
  [(set (match_operand:HISI 0 "nonimmediate_operand" "")
	(match_operand:HISI 1 "general_operand" ""))]
  ""
{
#if 0
  int modesize, i;
  bool need_clobber = false;
  rtx seq;
  
  /*dump_value_slim (stderr, operands[0], 0);
  fprintf (stderr, " <-- ");
  dump_value_slim (stderr, operands[1], 0);
  fprintf (stderr, "\n");*/
  
  if (<MODE>mode == HImode && can_create_pseudo_p ()
      && sym_const_operand (operands[1], HImode))
    {
      rtx op0lo = gen_lowpart (QImode, operands[0]), dstlo;
      rtx op0hi = gen_highpart_mode (QImode, HImode, operands[0]), dsthi;

      dstlo = op0lo;
      dsthi = op0hi;

      if (!hard_reg_operand (dstlo, QImode))
        dstlo = gen_reg_rtx (QImode);
      if (!hard_reg_operand (dsthi, QImode))
        dsthi = gen_reg_rtx (QImode);

      emit_move_insn (dstlo, m65x_gen_subreg (QImode, operands[1], HImode, 0));
      emit_move_insn (dsthi, m65x_gen_subreg (QImode, operands[1], HImode, 1));

      if (dstlo != op0lo)
        emit_move_insn (op0lo, dstlo);
      if (dsthi != op0hi)
        emit_move_insn (op0hi, dsthi);

      DONE;
    }
  else if (!lra_in_progress && can_create_pseudo_p ())
    {
      rtx dest = operands[0];
      modesize = GET_MODE_SIZE (<MODE>mode);

      /* We can only load symbol_ref/label_ref to an actual register.  */
      if (<MODE>mode == HImode
	  && !hard_reg_operand (operands[0], <MODE>mode)
	  && sym_const_operand (operands[1], <MODE>mode))
	operands[1] = force_reg (<MODE>mode, operands[1]);

      /* The below code is adapted from expr.c:emit_move_multi_word.  */

      if (reload_in_progress && MEM_P (operands[0]))
	{
	  rtx inner = find_replacement (&XEXP (operands[0], 0));
	  if (inner != XEXP (operands[0], 0))
            operands[0] = replace_equiv_address_nv (operands[0], inner);
	}

      if (reload_in_progress && MEM_P (operands[1]))
	{
	  rtx inner = find_replacement (&XEXP (operands[1], 0));
	  if (inner != XEXP (operands[1], 0))
            operands[1] = replace_equiv_address_nv (operands[1], inner);
	}

      if (!rtx_equal_p (operands[0], operands[1])
	  && REG_P (operands[0])
	  && reg_overlap_mentioned_p (operands[0], operands[1]))
	dest = gen_reg_rtx (<MODE>mode);

      start_sequence ();

      for (i = 0; i < modesize; i++)
	{
	  rtx xpart = operand_subword (dest, i, 1, <MODE>mode);
	  rtx ypart;

	 /* if (undefined_operand_subword_p (operands[1], i))
            continue;*/

	  ypart = operand_subword (operands[1], i, 1, <MODE>mode);

	  if (ypart == 0 && CONSTANT_P (operands[1]))
            {
	      operands[1] = use_anchored_address (force_const_mem (<MODE>mode,
						  operands[1]));
	      ypart = operand_subword (operands[1], i, 1, <MODE>mode);
	    }
	  else if (ypart == 0)
            ypart = operand_subword_force (operands[1], i, <MODE>mode);

	  gcc_assert (xpart && ypart);

	  need_clobber |= (GET_CODE (xpart) == SUBREG);

	  emit_move_insn (xpart, ypart);
	}

      seq = get_insns ();
      end_sequence ();

      if (dest != operands[1]
	  && ! (lra_in_progress || reload_in_progress || reload_completed)
	  && need_clobber)
	emit_clobber (dest);

      emit_insn (seq);

      if (dest != operands[0])
        emit_move_insn (operands[0], dest);

      DONE;
    }

  if (memory_operand (operands[0], <MODE>mode)
      && memory_operand (operands[1], <MODE>mode))
    operands[1] = force_reg (<MODE>mode, operands[1]);
#endif
})

; LRA gets very upset if it can't use a single instruction to move caller-saved
; registers out of the way (in split_reg). The following pattern is
; here to appease it, though ideally it wouldn't be necessary.

;(define_insn_and_split "mov<mode>_noclob"
;  [(set (match_operand:HISI 0 "nonimmediate_operand" "=&r,m,r,r")
;	(match_operand:HISI 1 "general_operand"        "r,r,m,i"))]
;  "m65x_real_insns_ok ()
;   && (register_operand (operands[0], <MODE>mode)
;       || register_operand (operands[1], <MODE>mode))
;   && (lra_in_progress || reload_completed)"
;  "#"
;  "&& reload_completed"
;  [(pc)]
;{
;  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
;  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
;  int i, modesize = GET_MODE_SIZE (<MODE>mode);
;
;  if (rtx_equal_p (operands[0], operands[1]))
;    DONE;
;
;  emit_insn (m65x_push (QImode, acc));
;
;  if (indirect_mem_operand (operands[1], <MODE>mode)
;      || indirect_offset_mem_operand (operands[1], <MODE>mode))
;    {
;      rtx addr = XEXP (operands[1], 0);
;      HOST_WIDE_INT offset;
;      rtx base;
;
;      if (REG_P (addr))
;        {
;	  base = addr;
;	  offset = 0;
;	}
;      else if (GET_CODE (addr) == PLUS)
;        {
;	  base = XEXP (addr, 0);
;	  offset = INTVAL (XEXP (addr, 1));
;	}
;      else
;        gcc_unreachable ();
;
;      if (TARGET_PHX)
;	emit_insn (m65x_push (QImode, yreg));
;      else
;        {
;	  emit_move_insn (acc, yreg);
;	  emit_insn (m65x_push (QImode, acc));
;	}
;      emit_move_insn (yreg, gen_int_mode (offset, QImode));
;
;      for (i = 0; i < modesize; i++)
;        {
;	  rtx dstpart = simplify_gen_subreg (QImode, operands[0],
;					     <MODE>mode, i);
;	  emit_insn (gen_loadqi_indy (acc, yreg, base));
;	  emit_move_insn (dstpart, acc);
;	  if (i != modesize - 1)
;	    emit_insn (gen_incdecqi3 (yreg, yreg, const1_rtx));
;	}
;
;      if (TARGET_PHX)
;	emit_insn (m65x_pop (QImode, yreg));
;      else
;        {
;	  emit_insn (m65x_pop (QImode, acc));
;	  emit_move_insn (yreg, acc);
;	}
;    }
;  else if (indirect_mem_operand (operands[0], <MODE>mode)
;	   || indirect_offset_mem_operand (operands[0], <MODE>mode))
;    {
;      rtx addr = XEXP (operands[0], 0);
;      HOST_WIDE_INT offset;
;      rtx base;
;
;      if (REG_P (addr))
;        {
;	  base = addr;
;	  offset = 0;
;	}
;      else if (GET_CODE (addr) == PLUS)
;        {
;	  base = XEXP (addr, 0);
;	  offset = INTVAL (XEXP (addr, 1));
;	}
;      else
;        gcc_unreachable ();
;
;      if (TARGET_PHX)
;	emit_insn (m65x_push (QImode, yreg));
;      else
;        {
;	  emit_move_insn (acc, yreg);
;	  emit_insn (m65x_push (QImode, acc));
;	}
;
;      emit_move_insn (yreg, gen_int_mode (offset, QImode));
;      
;      for (i = 0; i < modesize; i++)
;        {
;	  rtx srcpart = simplify_gen_subreg (QImode, operands[1],
;					     <MODE>mode, i);
;	  emit_move_insn (acc, srcpart);
;	  emit_insn (gen_storeqi_indy (yreg, base, acc));
;	  if (i != modesize - 1)
;	    emit_insn (gen_incdecqi3 (yreg, yreg, const1_rtx));
;	}
;      
;      if (TARGET_PHX)
;	emit_insn (m65x_pop (QImode, yreg));
;      else
;        {
;	  emit_insn (m65x_pop (QImode, acc));
;	  emit_move_insn (yreg, acc);
;	}
;    }
;  else
;    {
;      bool backwards = false;
;
;      if (REG_P (operands[0]) && operands[0] != operands[1]
;	  && reg_overlap_mentioned_p (operands[0], operands[1]))
;	{
;	  gcc_assert (REG_P (operands[0])
;		      && IS_ZP_REGNUM (REGNO (operands[0])));
;	  gcc_assert (REG_P (operands[1])
;		      && IS_ZP_REGNUM (REGNO (operands[1])));
;	  if (REGNO (operands[0]) < REGNO (operands[1]))
;	    backwards = true;
;	}
;
;      if (backwards)
;	for (i = modesize - 1; i >= 0; i--)
;	  {
;	    rtx dstpart = simplify_gen_subreg (QImode, operands[0],
;					       <MODE>mode, i);
;	    rtx srcpart = simplify_gen_subreg (QImode, operands[1],
;					       <MODE>mode, i);
;	    emit_move_insn (acc, srcpart);
;	    emit_move_insn (dstpart, acc);
;	  }
;      else
;	for (i = 0; i < modesize; i++)
;	  {
;	    rtx dstpart = simplify_gen_subreg (QImode, operands[0],
;					       <MODE>mode, i);
;	    rtx srcpart = simplify_gen_subreg (QImode, operands[1],
;					       <MODE>mode, i);
;	    emit_move_insn (acc, srcpart);
;	    emit_move_insn (dstpart, acc);
;	  }
;    }
;  
;  emit_insn (m65x_pop (QImode, acc));
;  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));
;  
;  DONE;
;})

;(define_expand "add<mode>3"
;  [(parallel [(set (match_operand:HISI 0 "nonimmediate_operand" "")
;		   (plus:HISI (match_operand:HISI 1 "general_operand" "")
;			      (match_operand:HISI 2 "general_operand" "")))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])]
;  ""
;{
;#if 0
;#if 0
;  /* Eagerly splitting up adds used to calculate addresses is
;     counterproductive, because it inhibits middle-end passes which deal with
;     addressing modes, etc.  FIXME.  */
;  if ((REG_P (operands[1]) && REG_POINTER (operands[1]))
;      || (REG_P (operands[2]) && REG_POINTER (operands[2]))
;      || sym_const_operand (operands[1], <MODE>mode)
;      || sym_const_operand (operands[2], <MODE>mode))
;    {
;      emit_insn (gen_addhi3_noclob (operands[0], operands[1], operands[2]));
;      DONE;
;    }
;#endif
;
;  if (can_create_pseudo_p ())
;    {
;#if 0
;      /* This doesn't really work either, because it creates RTL that's hard to
;	 deal with later.  */
;      rtx base, index;
;      bool op1ptr, op2ptr;
;
;      op1ptr = REG_P (operands[1]) && REG_POINTER (operands[1]);
;      op2ptr = REG_P (operands[2]) && REG_POINTER (operands[2]);
;
;      if (op1ptr && !op2ptr)
;	{
;	  base = operands[1];
;	  index = operands[2];
;	}
;      else
;	{
;	  base = operands[2];
;	  index = operands[1];
;	}
;
;      if (!op1ptr ^ !op2ptr)
;	{
;	  rtx idx_lo, idx_hi, tmp_hi;
;	  rtx tmp = gen_reg_rtx (HImode);
;
;	  idx_lo = operand_subword (index, 0, 1, HImode);
;	  idx_hi = operand_subword (index, 1, 1, HImode);
;	  tmp_hi = operand_subword (tmp, 1, 1, HImode);
;
;	  emit_move_insn (tmp, base);
;	  emit_insn (gen_addqi3 (tmp_hi, tmp_hi, idx_hi));
;
;	  rtx x = gen_rtx_PLUS (HImode,
;		   gen_rtx_ZERO_EXTEND (HImode, force_reg (QImode, idx_lo)),
;					tmp);
;	  emit_move_insn (operands[0], x);
;	}
;      else
;#endif
;	m65x_expand_addsub (<MODE>mode, true, operands);
;      DONE;
;    }
;#endif
;})

(define_expand "add<mode>3"
  [(set (match_operand:HISI 0 "register_operand" "")
	(plus:HISI (match_operand:HISI 1 "register_operand" "")
		   (match_operand:HISI 2 "nonmemory_operand" "")))]
  ""
{})

; An add that is generated post-reload (not by LRA), e.g. during prologue
; emission. Cannot clobber accumulator. (Prologue insns also can't be split --
; maybe splitting should be done "long hand".)

(define_insn "addhi3_noclobacc"
  [(set (match_operand:HI 0 "register_operand"          "=&r,r")
	(plus:HI (match_operand:HI 1 "register_operand"   "r,r")
		 (match_operand:HI 2 "nonmemory_operand"  "r,i")))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  "m65x_real_insns_ok () && reload_completed"
  "@
  sta _tmp0\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;lda _tmp0
  sta _tmp0\;lda %1\;clc\;adc #%L2\;sta %0\;lda %h1\;adc #%H2\;sta %h0\;lda _tmp0"
  [(set_attr "length" "17,17")])

; Similar, except this one clobbers the accumulator.  Generated
; opportunistically by the md-reorg pass.

(define_insn "addhi3_clobacc"
  [(set (match_operand:HI 0 "register_operand"          "=&r,r")
	(plus:HI (match_operand:HI 1 "register_operand"   "r,r")
		 (match_operand:HI 2 "nonmemory_operand"  "r,i")))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))
   (clobber (reg:QI ACC_REGNUM))]
  "m65x_real_insns_ok () && reload_completed"
  "@
  lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0
  lda %1\;clc\;adc #%L2\;sta %0\;lda %h1\;adc #%H2\;sta %h0"
  [(set_attr "length" "13,13")])

; This pattern is used primarily during LRA.  This version really can't clobber
; anything, including the flags register.  This pattern is generated directly,
; it doesn't come via the addhi3 expander.

;(define_insn "addhi3_noclob"
;  [(set (match_operand:HI 0 "register_operand"		 "=&r,r")
;	(plus:HI (match_operand:HI 1 "register_operand"   "%r,r")
;		 (match_operand:HI 2 "nonmemory_operand"   "r,i")))]
;  "m65x_real_insns_ok ()"
;  "@
;  php\;sta _tmp0\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;lda _tmp0\;plp
;  php\;sta _tmp0\;lda %1\;clc\;adc #%L2\;sta %0\;lda %h1\;adc #%H2\;sta %h0\;lda _tmp0\;plp"
;  [(set_attr "length" "19,19")])

(define_expand "sub<mode>3"
  [(set (match_operand:HISI 0 "register_operand" "")
	(minus:HISI (match_operand:HISI 1 "register_operand" "")
		    (match_operand:HISI 2 "register_operand" "")))]
  "can_create_pseudo_p ()"
{
  /*if (m65x_real_insns_ok ())
    {
      m65x_expand_addsub (<MODE>mode, false, operands);
      DONE;
    }*/
})

(define_expand "lshrhi3"
  [(set (match_operand:HI 0 "reg_or_const_mem_operand" "")
	(lshiftrt:HI (match_operand:HI 1 "reg_or_const_mem_operand" "")
		     (match_operand:HI 2 "shifthi_amount" "")))]
  "can_create_pseudo_p ()"
{
  HOST_WIDE_INT shiftamt = INTVAL (operands[2]);

  switch (shiftamt)
    {
    case 1:
    case 2:
    case 3:
    case 4:
      {
        rtx tmp = gen_reg_rtx (HImode);
        int i;

	emit_move_insn (tmp, operands[1]);

	rtx tmphi = gen_highpart_mode (QImode, HImode, tmp);
	rtx tmplo = gen_lowpart (QImode, tmp);

	for (i = 1; i <= shiftamt; i++)
	  {
	    emit_insn (gen_lshrqi3_insn (tmphi, tmphi, const1_rtx));
	    emit_insn (gen_m65x_rorqi3 (tmplo, tmplo));
	  }

	emit_move_insn (operands[0], tmp);
      }
      break;

    case 5:
    case 6:
      {
	int i;
        rtx tmp = gen_reg_rtx (QImode);
	rtx tmp2 = gen_reg_rtx (HImode), tmplo, tmphi;

	/* lshr #5			  lshr #6
	   -------			  -------
	   hhhhhhhh llllllll ->           hhhhhhhh llllllll ->
	   00000000 hhhhhhhh llllllll ->  00000000 hhhhhhhh llllllll->
	   00000hhh hhhhhlll lllll000 ->  000000hh hhhhhhll llllll00 ->
	   00000hhh hhhhhlll		  000000hh hhhhhhll.  */

	tmplo = gen_lowpart (QImode, tmp2);
	tmphi = gen_highpart_mode (QImode, HImode, tmp2);

        emit_move_insn (tmp, gen_lowpart (QImode, operands[1]));
	emit_move_insn (tmplo, gen_highpart_mode (QImode, HImode,
						  operands[1]));
	emit_move_insn (tmphi, const0_rtx);

	for (i = 8; i > shiftamt; i--)
	  {
	    emit_insn (gen_ashlqi3_insn (tmp, tmp, const1_rtx));
	    emit_insn (gen_m65x_rolqi3 (tmplo, tmplo));
	    emit_insn (gen_m65x_rolqi3 (tmphi, tmphi));
	  }

	emit_move_insn (operands[0], tmp2);
      }
      break;

    case 7:
      {
	rtx tmp = gen_reg_rtx (HImode);
	rtx tmp2 = gen_reg_rtx (QImode);
	/* hhhhhhhh llllllll ->
           0000000h hhhhhhhl.  */
	emit_insn (gen_ashlqi3_insn (tmp2,
				     gen_lowpart (QImode, operands[1]),
				     const1_rtx));
	emit_insn (gen_m65x_rolqi3 (gen_lowpart (QImode, tmp),
				    gen_highpart_mode (QImode, HImode,
						       operands[1])));
	emit_insn (gen_m65x_rolqi3 (gen_highpart_mode (QImode, HImode, tmp),
				    force_reg (QImode, const0_rtx)));
	emit_move_insn (operands[0], tmp);
      }
      break;

    case 8:
      {
	emit_move_insn (gen_lowpart (QImode, operands[0]),
			gen_highpart_mode (QImode, HImode, operands[1]));
	emit_move_insn (gen_highpart_mode (QImode, HImode, operands[0]),
			const0_rtx);
      }
      break;

    /* Shifts of 9-16 are handled reasonably well by generic expanders using
       lshrqi3, so no need to duplicate that here.  */

    default:
      FAIL;
    }

  DONE;
})

(define_expand "ashlhi3"
  [(set (match_operand:HI 0 "reg_or_const_mem_operand" "")
	(ashift:HI (match_operand:HI 1 "reg_or_const_mem_operand" "")
		   (match_operand:HI 2 "shifthi_amount" "")))]
  "can_create_pseudo_p ()"
{
  HOST_WIDE_INT shiftamt = INTVAL (operands[2]);

  switch (shiftamt)
    {
    case 1:
    case 2:
    case 3:
    case 4:
      {
	rtx tmp = gen_reg_rtx (HImode);
	int i;

	emit_move_insn (tmp, operands[1]);

	rtx tmphi = gen_highpart_mode (QImode, HImode, tmp);
	rtx tmplo = gen_lowpart (QImode, tmp);

	for (i = 1; i <= shiftamt; i++)
	  {
	    emit_insn (gen_ashlqi3_insn (tmplo, tmplo, const1_rtx));
	    emit_insn (gen_m65x_rolqi3 (tmphi, tmphi));
	  }

	emit_move_insn (operands[0], tmp);
      }
      break;

    case 5:
    case 6:
      {
	/* ashl #5			  ashl #6
	   -------			  -------
	            hhhhhhhh llllllll ->   hhhhhhhh llllllll ->
           hhhhhhhh llllllll 00000000 ->   hhhhhhhh llllllll 00000000 ->
           ...hhhhh hhhlllll lll00000      ..hhhhhh hhllllll ll000000.  */
	rtx tmp = gen_reg_rtx (QImode);
	rtx tmp2 = gen_reg_rtx (HImode), tmplo, tmphi;
	int i;

	tmplo = gen_lowpart (QImode, tmp2);
	tmphi = gen_highpart_mode (QImode, HImode, tmp2);

	emit_move_insn (tmp, gen_highpart_mode (QImode, HImode,
						operands[1]));
	emit_move_insn (tmphi, gen_lowpart (QImode, operands[1]));
	emit_move_insn (tmplo, const0_rtx);

	for (i = 8; i > shiftamt; i--)
	  {
            emit_insn (gen_lshrqi3_insn (tmp, tmp, const1_rtx));
	    emit_insn (gen_m65x_rorqi3 (tmphi, tmphi));
	    emit_insn (gen_m65x_rorqi3 (tmplo, tmplo));
	  }

	emit_move_insn (operands[0], tmp2);
      }
      break;

    case 7:
      {
	rtx tmp = gen_reg_rtx (HImode);
	rtx tmp2 = gen_reg_rtx (QImode);

        /* hhhhhhhh llllllll ->
	   hlllllll l0000000.  */

	emit_insn (gen_lshrqi3_insn (tmp2, gen_highpart_mode (QImode,
							      HImode,
							      operands[1]),
				     const1_rtx));
	emit_insn (gen_m65x_rorqi3 (gen_highpart_mode (QImode, HImode, tmp),
				    gen_lowpart (QImode, operands[1])));
	emit_insn (gen_m65x_rorqi3 (gen_lowpart (QImode, tmp),
				    force_reg (QImode, const0_rtx)));
	emit_move_insn (operands[0], tmp);
      }
      break;

    default:
      FAIL;
    }

  DONE;
})

;(define_insn "ashrhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(ashiftrt:HI (match_operand:HI 1 "accumulator_operand"   "0, 0")
;		     (match_operand:HI 2 "shifthi_amount"	 "Na,Nb")))
;   (clobber (match_scratch:QI 3 "=&jq,X"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a";
;    case 2:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a";
;    case 3:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a\;cp%R3 #$80\;ror _ah\;ror a";
;    case 4:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;ror a";
;    case 5:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #7\;ld%R3 _ah\;sta _ah\;and #4\;beq :+\;lda _ah\;ora #$f8\;"
;	     "sta _ah\;:\;t%R3a";
;    case 6:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;and #3\;ld%R3 _ah\;"
;	     "sta _ah\;and #2\;beq :+\;lda _ah\;ora #$fc\;sta _ah\;:\;t%R3a";
;    case 7:
;      return "cmp #$80\;rol _ah\;lda #0\;sbc #0\;eor #$ff\;ld%R3 _ah\;sta _ah\;"
;	     "t%R3a";
;    case 8:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a";
;    case 9:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a";
;    case 10:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a";
;    case 11:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
;    case 12:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;"
;	     "ror a";
;    case 13:
;      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
;	     "asl _ah\;rol a\;asl _ah\;rol a\;st%R3 _ah";
;    case 14:
;      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
;	     "asl _ah\;rol a\;st%R3 _ah";
;    case 15:
;    case 16:
;      return "asl _ah\;lda #0\;sbc #0\;eor #$ff\;sta _ah";
;    }
;  return "";
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 7)
;	       (eq (match_dup 2) (const_int 2)) (const_int 12)
;	       (eq (match_dup 2) (const_int 3)) (const_int 17)
;	       (eq (match_dup 2) (const_int 4)) (const_int 22)
;	       (eq (match_dup 2) (const_int 5)) (const_int 28)
;	       (eq (match_dup 2) (const_int 6)) (const_int 25)
;	       (eq (match_dup 2) (const_int 7)) (const_int 15)
;	       (eq (match_dup 2) (const_int 8)) (const_int 12)
;	       (eq (match_dup 2) (const_int 9)) (const_int 15)
;	       (eq (match_dup 2) (const_int 10)) (const_int 18)
;	       (eq (match_dup 2) (const_int 11)) (const_int 21)
;	       (eq (match_dup 2) (const_int 12)) (const_int 24)
;	       (eq (match_dup 2) (const_int 13)) (const_int 20)
;	       (eq (match_dup 2) (const_int 14)) (const_int 17)
;	       (eq (match_dup 2) (const_int 15)) (const_int 10)
;	       (eq (match_dup 2) (const_int 16)) (const_int 10)]
;	      (const_int 0)))])

(define_expand "cbranchhi4"
  [(parallel
    [(set (pc) (if_then_else
		 (match_operator 0 "m65x_comparison"
	           [(match_operand:HI 1 "register_operand" "")
		    (match_operand:HI 2 "nonmemory_operand" "")])
		 (label_ref (match_operand 3 "" ""))
		 (pc)))
     (clobber (match_scratch:QI 4 ""))])]
  ""
{
  int force_reg_operand;

  switch (GET_CODE (operands[0]))
    {
    case GTU:
    case LEU:
    case GT:
    case LE:
      force_reg_operand = 2;
      break;

    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      force_reg_operand = 1;
      break;

    default:
      gcc_unreachable ();
    }

  if (can_create_pseudo_p () &&
      !register_operand (operands[force_reg_operand], HImode))
    operands[force_reg_operand] = force_reg (HImode,
					     operands[force_reg_operand]);
})

(define_insn_and_split "cbrhi_eq"
  [(set (pc) (if_then_else
	       (eq (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (EQ, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ne"
  [(set (pc) (if_then_else
	       (ne (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (NE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ltu"
  [(set (pc) (if_then_else
	       (ltu (match_operand:HI 0 "zp_reg_operand"        "r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gtu"
  [(set (pc) (if_then_else
	       (gtu (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		    (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_geu"
  [(set (pc) (if_then_else
	       (geu (match_operand:HI 0 "zp_reg_operand"         "r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand"  "r,i"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_leu"
  [(set (pc) (if_then_else
	       (leu (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		    (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_lt"
  [(set (pc) (if_then_else
	       (lt (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gt"
  [(set (pc) (if_then_else
	       (gt (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ge"
  [(set (pc) (if_then_else
	       (ge (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_le"
  [(set (pc) (if_then_else
	       (le (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "zp_reg_operand" "")
	(sign_extend:SI (match_operand:HI 1 "zp_reg_operand" "")))]
  "m65x_real_insns_ok ()"
{
  rtx acc = gen_reg_rtx (QImode);
  rtx cmp, new_label = gen_label_rtx ();
  
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 0),
		  simplify_gen_subreg (QImode, operands[1], HImode, 0));
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 1),
		  simplify_gen_subreg (QImode, operands[1], HImode, 1));

  emit_move_insn (acc, simplify_gen_subreg (QImode, operands[1], HImode, 1));
  emit_insn (gen_iorqi3_nz (acc, acc, gen_int_mode (0x7f, QImode)));
  cmp = gen_rtx_LT (VOIDmode, gen_rtx_REG (CC_NZmode, NZ_REGNUM), const0_rtx);
  emit_jump_insn (gen_rtx_SET (pc_rtx,
			       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,
				 gen_rtx_LABEL_REF (Pmode, new_label),
				 pc_rtx)));
  emit_move_insn (acc, const0_rtx);
  emit_label (new_label);

  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 2), acc);
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 3), acc);
  
  DONE;
})

(define_expand "neghi2"
  [(set (match_operand:HI 0 "reg_or_const_mem_operand" "")
	(neg:HI (match_operand:HI 1 "reg_or_const_mem_operand" "")))]
  "m65x_real_insns_ok ()"
{
  rtx zero = force_reg (HImode, const0_rtx);
  emit_insn (gen_subhi3 (operands[0], zero, operands[1]));
  DONE;
})

;(define_expand "zero_extendqihi2"
;  [(set (match_operand:HI 0 "zp_reg_operand" "")
;        (zero_extend:HI (match_operand:QI 1 "y_reg_operand" "")))]
;  ""
;{})

; QImode operations.

(define_expand "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
{
#if 0
  if (can_create_pseudo_p ())
    {
      if (MEM_P (operands[0])
	  && MEM_ADDR_SPACE (operands[0]) == ADDR_SPACE_GENERIC
	  && ((MEM_P (operands[1])
	       && MEM_ADDR_SPACE (operands[1]) == ADDR_SPACE_GENERIC)
	      || (GET_CODE (operands[1]) == CONST_INT
		  && (INTVAL (operands[1]) != 0
		      || !CONSTANT_ADDRESS_P (XEXP (operands[0], 0))))
	      || (!CONSTANT_ADDRESS_P (XEXP (operands[0], 0))
		  && REG_P (operands[1])
		  && REGNO (operands[1]) != ACC_REGNUM)
	      || !REG_P (operands[1])))
	operands[1] = force_reg (QImode, operands[1]);
      else if (strict_ptr_reg_operand (operands[0], QImode)
	       && immediate_operand (operands[1], QImode)
	       && !(CONST_INT_P (operands[1]) && INTVAL (operands[1]) == 0
		    && TARGET_STZ))
	operands[1] = force_reg (QImode, operands[1]);
      else if (((MEM_P (operands[0])
		 && MEM_ADDR_SPACE (operands[0]) == ADDR_SPACE_GENERIC)
		|| strict_ptr_reg_operand (operands[0], QImode)
		|| reg_mentioned_p (frame_pointer_rtx, operands[0])
		|| reg_mentioned_p (virtual_stack_vars_rtx, operands[0]))
	       && ((MEM_P (operands[1])
		    && MEM_ADDR_SPACE (operands[1]) == ADDR_SPACE_GENERIC)
		   || strict_ptr_reg_operand (operands[1], QImode)
		   || reg_mentioned_p (frame_pointer_rtx, operands[1])
		   || reg_mentioned_p (virtual_stack_vars_rtx, operands[1])))
	operands[1] = copy_to_mode_reg (QImode, operands[1]);
      else if ((MEM_P (operands[0])
		&& MEM_ADDR_SPACE (operands[0]) == ADDR_SPACE_ZP
		&& !hard_reg_operand (operands[1], QImode))
	       || (MEM_P (operands[1])
		   && MEM_ADDR_SPACE (operands[1]) == ADDR_SPACE_ZP
		   && !hard_reg_operand (operands[0], QImode)))
	operands[1] = copy_to_mode_reg (QImode, operands[1]);
    }

  if (operands[0] == operands[1])
    DONE;
#endif
})

;(define_insn "loadqi_zp"
;  [(set (match_operand:QI 0 "hard_reg_operand" "=hq")
;	(match_operand:QI 1 "zp_memory_operand" "m"))
;   (clobber (reg:CC_NZ NZ_REGNUM))]
;  "m65x_real_insns_ok ()"
;  "ld%R0 %1"
;  [(set_attr "length" "2")])

;(define_insn "storeqi_zp"
;  [(set (match_operand:QI 0 "zp_memory_operand" "=m")
;	(match_operand:QI 1 "hard_reg_operand"  "hq"))
;   (clobber (reg:CC_NZ NZ_REGNUM))]
;  "m65x_real_insns_ok ()"
;  "st%R1 %0"
;  [(set_attr "length" "2")])

(define_insn "movqi_noclob"
  [(set (match_operand:QI 0 "nonimmediate_operand"
	       "=hq,hq, r,hq,Uc,hq, <,hq, <,Aq,Aq, m,r,Uc,?hq, ?m,?r,?m,rhq")
	(match_operand:QI 1 "general_operand"
		 "i, r,hq,Uc,hq,hq,hq, >,Aq, >, m,Aq,z, z, ?m,?hq,?m,?r,  0"))]
  "m65x_real_insns_ok ()
   && m65x_valid_mov_operands (QImode, operands, true)"
{
  return m65x_print_movqi (which_alternative, operands, true);
}
  [(set_attr "length" "4,4,4,5,5,6,3,3,3,3,10,10,4,5,11,15,16,16,0")
   (set_attr "arch" "*,*,*,*,*,*,phx,phx,no_phx,no_phx,*,*,cmos,cmos,*,*,\
		     *,*,*")])

; Note: we need the "r<-m" and "m<-r" constraints because LRA doesn't want
; to use single-register classes (i.e. the accumulator) as a target.  We'll
; have to try our best to clean up post-reload.

(define_insn "movqi_insn"
  [(set (match_operand:QI 0 "nonimmediate_operand"
	       "=hq,hq, r,hq,Uc,hq, <,hq, <,Aq,Aq, m,r,Uc,?hq, ?m,?r,?m,rhq")
	(match_operand:QI 1 "general_operand"
		 "i, r,hq,Uc,hq,hq,hq, >,Aq, >, m,Aq,z, z, ?m,?hq,?m,?r,  0"))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "m65x_real_insns_ok ()
   && m65x_valid_mov_operands (QImode, operands, true)"
{
  return m65x_print_movqi (which_alternative, operands, false);
}
  [(set_attr "length" "2,2,2,3,3,4,1,1,1,1,8,8,2,3,9,13,14,14,0")
   (set_attr "arch" "*,*,*,*,*,*,phx,phx,no_phx,no_phx,*,*,cmos,cmos,*,*,\
		     *,*,*")])

; We really want that clobber. If we can put it there, do so.

;(define_peephole2
;  [(set (match_operand:QI 0 "nonimmediate_operand" "")
;	(match_operand:QI 1 "general_operand" ""))]
;  "peep2_regno_dead_p (1, NZ_REGNUM)"
;  [(parallel [(set (match_dup 0) (match_dup 1))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

; Fix up indirect ZP/index register loads.

;(define_peephole2
;  [(parallel [(set (match_operand:QI 0 "zp_or_index_reg_operand" "")
;		   (mem:QI (match_operand:HI 1 "zp_reg_operand" "")))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_load (operands[0], operands[1], NULL_RTX, true))
;    DONE;
;  else
;    FAIL;
;})

;(define_peephole2
;  [(set (match_operand:QI 0 "zp_or_index_reg_operand" "")
;	(mem:QI (match_operand:HI 1 "zp_reg_operand" "")))]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_load (operands[0], operands[1], NULL_RTX, false))
;    DONE;
;  else
;    FAIL;
;})

; Fix up index/ZP indirect-indexed loads.

;(define_peephole2
;  [(parallel [(set (match_operand:QI 0 "zp_or_index_reg_operand" "")
;		   (mem:QI
;		     (plus:HI (zero_extend:HI
;				(match_operand:QI 1 "y_reg_operand" ""))
;			      (match_operand:HI 2 "zp_reg_operand" ""))))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_load (operands[0], operands[2], operands[1], true))
;    DONE;
;  else
;    FAIL;
;})

;(define_peephole2
;  [(set (match_operand:QI 0 "zp_or_index_reg_operand" "")
;	(mem:QI (plus:HI (zero_extend:HI
;			   (match_operand:QI 1 "y_reg_operand" ""))
;		(match_operand:HI 2 "zp_reg_operand" ""))))]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_load (operands[0], operands[2], operands[1], false))
;    DONE;
;  else
;    FAIL;
;})

; Try to fix up indirect index/ZP register stores.

;(define_peephole2
;  [(parallel [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" ""))
;		   (match_operand:QI 1 "zp_or_index_reg_operand" ""))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_store (operands[0], NULL_RTX, operands[1], true))
;    DONE;
;  else
;    FAIL;
;})

;(define_peephole2
;  [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" ""))
;	(match_operand:QI 1 "zp_or_index_reg_operand" ""))]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_store (operands[0], NULL_RTX, operands[1], false))
;    DONE;
;  else
;    FAIL;
;})

; Fix up ZP indirect-indexed stores.

;(define_peephole2
;  [(parallel [(set (mem:QI
;		     (plus:HI (zero_extend:HI
;				(match_operand:QI 0 "y_reg_operand" ""))
;			      (match_operand:HI 1 "zp_reg_operand" "")))
;		   (match_operand:QI 2 "zp_or_index_reg_operand" ""))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_store (operands[1], operands[0], operands[2], true))
;    DONE;
;  else
;    FAIL;
;})

;(define_peephole2
;  [(set (mem:QI (plus:HI (zero_extend:HI
;			   (match_operand:QI 0 "y_reg_operand" ""))
;			 (match_operand:HI 1 "zp_reg_operand" "")))
;		(match_operand:QI 2 "zp_or_index_reg_operand" ""))]
;  "m65x_real_insns_ok ()"
;  [(pc)]
;{
;  if (m65x_peep_store (operands[1], operands[0], operands[2], false))
;    DONE;
;  else
;    FAIL;
;})

; Fix up indirect accumulator loads.

;(define_peephole2
;  [(parallel [(set (match_operand:QI 0 "accumulator_operand" "")
;		   (mem:QI (match_operand:HI 1 "zp_reg_operand" "")))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok () && !TARGET_ZPIND"
;  [(pc)]
;{
;  if (m65x_peep_load (operands[0], operands[1], NULL_RTX, true))
;    DONE;
;  else
;    FAIL;
;})

;(define_peephole2
;  [(set (match_operand:QI 0 "accumulator_operand" "")
;	(mem:QI (match_operand:HI 1 "zp_reg_operand" "")))]
;  "m65x_real_insns_ok () && !TARGET_ZPIND"
;  [(pc)]
;{
;  if (m65x_peep_load (operands[0], operands[1], NULL_RTX, false))
;    DONE;
;  else
;    FAIL;
;})

; Fix up indirect accumulator stores.

;(define_peephole2
;  [(parallel [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" ""))
;		   (match_operand:QI 1 "accumulator_operand" ""))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok () && !TARGET_ZPIND"
;  [(pc)]
;{
;  if (m65x_peep_store (operands[0], NULL_RTX, operands[1], true))
;    DONE;
;  else
;    FAIL;
;})

;(define_peephole2
;  [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" ""))
;	(match_operand:QI 1 "accumulator_operand" ""))]
;  "m65x_real_insns_ok () && !TARGET_ZPIND"
;  [(pc)]
;{
;  if (m65x_peep_store (operands[0], NULL_RTX, operands[1], false))
;    DONE;
;  else
;    FAIL;
;})

; Fix up moves between ZP locations.

;(define_peephole2
;  [(parallel [(set (match_operand:QI 0 "zp_reg_operand" "")
;		   (match_operand:QI 1 "zp_reg_operand" ""))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (match_scratch:QI 2 "hq")]
;  "m65x_real_insns_ok ()"
;  [(parallel [(set (match_dup 2) (match_dup 1))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (parallel [(set (match_dup 0) (match_dup 2))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

;(define_peephole2
;  [(set (match_operand:QI 0 "zp_reg_operand" "")
;	(match_operand:QI 1 "zp_reg_operand" ""))
;   (match_scratch:QI 2 "hq")]
;  "m65x_real_insns_ok () && peep2_regno_dead_p (1, NZ_REGNUM)"
;  [(parallel [(set (match_dup 2) (match_dup 1))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (parallel [(set (match_dup 0) (match_dup 2))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

; Fix up absolute-indexed loads.

;(define_peephole2
;  [(match_scratch:QI 3 "hq")
;   (parallel [(set (match_operand:QI 0 "zp_reg_operand" "")
;	           (mem:QI
;		     (plus:HI (zero_extend:HI
;				(match_operand:QI 1 "index_reg_operand" ""))
;			      (match_operand:HI 2 "sym_const_operand" ""))))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;  "m65x_real_insns_ok ()"
;  [(parallel [(set (match_dup 3) (mem:QI (plus:HI
;					   (zero_extend:HI (match_dup 1))
;					   (match_dup 2))))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (parallel [(set (match_dup 0) (match_dup 3))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

;(define_peephole2
;  [(match_scratch:QI 3 "hq")
;   (set (match_operand:QI 0 "zp_reg_operand" "")
;	(mem:QI (plus:HI (zero_extend:HI
;			   (match_operand:QI 1 "index_reg_operand" ""))
;		(match_operand:HI 2 "sym_const_operand" ""))))]
;  "m65x_real_insns_ok () && peep2_regno_dead_p (1, NZ_REGNUM)"
;  [(parallel [(set (match_dup 3) (mem:QI (plus:HI
;					   (zero_extend:HI (match_dup 1))
;					   (match_dup 2))))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (parallel [(set (match_dup 0) (match_dup 3))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

; Fix up absolute-indexed stores.

;(define_peephole2
;  [(parallel [(set (mem:QI
;		     (plus:HI (zero_extend:HI
;				(match_operand:QI 0 "index_reg_operand" ""))
;			      (match_operand:HI 1 "sym_const_operand" "")))
;		   (match_operand:QI 2 "zp_reg_operand" ""))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (match_scratch:QI 3 "Aq")]
;  "m65x_real_insns_ok ()"
;  [(parallel [(set (match_dup 3) (match_dup 2))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (parallel [(set (mem:QI (plus:HI (zero_extend:HI (match_dup 0))
;				    (match_dup 1)))
;		   (match_dup 3))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

;(define_peephole2
;  [(set (mem:QI (plus:HI (zero_extend:HI
;			   (match_operand:QI 0 "index_reg_operand" ""))
;			 (match_operand:HI 1 "sym_const_operand" "")))
;	(match_operand:QI 2 "zp_reg_operand" ""))
;   (match_scratch:QI 3 "Aq")]
;  "m65x_real_insns_ok () && peep2_regno_dead_p (1, NZ_REGNUM)"
;  [(parallel [(set (match_dup 3) (match_dup 2))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])
;   (parallel [(set (mem:QI (plus:HI (zero_extend:HI (match_dup 0))
;				    (match_dup 1)))
;		   (match_dup 3))
;	      (clobber (reg:CC_NZ NZ_REGNUM))])]
;)

; Fix up absolute loads to ZP regs.

;(define_peephole2
;  [(set (match_operand:QI 0 "zp_reg_operand" "")
;	(mem:QI (match_operand:HI 1 "sym_const_operand")))
;   (match_scratch:QI 2 "hq")]
;  "m65x_real_insns_ok ()"
;  [(set (match_dup 2) (mem:QI (match_dup 1)))
;   (set (match_dup 0) (match_dup 2))]
;)

; Fix up absolute stores of ZP regs.

;(define_peephole2
;  [(set (mem:QI (match_operand:HI 0 "sym_const_operand"))
;	(match_operand:QI 1 "zp_reg_operand" ""))
;   (match_scratch:QI 2 "hq")]
;  "m65x_real_insns_ok ()"
;  [(set (match_dup 2) (match_dup 1))
;   (set (mem:QI (match_dup 0)) (match_dup 2))]
;)

(define_expand "loadqi_indy"
  [(set (match_operand:QI 0 "accumulator_operand" "")
	(mem:QI
	  (plus:HI (zero_extend:HI (match_operand:QI 1 "y_reg_operand" ""))
		   (match_operand:HI 2 "zp_reg_operand" ""))))]
  ""
  {})

(define_expand "loadqi_indy_nz"
  [(parallel [(set (match_operand:QI 0 "accumulator_operand" "")
		   (mem:QI
		     (plus:HI
		       (zero_extend:HI (match_operand:QI 1 "y_reg_operand" ""))
		       (match_operand:HI 2 "zp_reg_operand" ""))))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  {})

(define_insn "loadqi_xind"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(mem:QI (unspec:QI [(match_operand:HI 1 "zp_reg_operand" "r")
			    (match_operand:QI 2 "x_reg_operand" "xq")]
			   UNSPEC_XIND)))]
  "m65x_real_insns_ok ()"
  "php\;lda (%1,x)\;plp"
  [(set_attr "length" "4")])

(define_insn "loadqi_xind_nz"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(mem:QI (unspec:QI [(match_operand:HI 1 "zp_reg_operand" "r")
			    (match_operand:QI 2 "x_reg_operand" "xq")]
			   UNSPEC_XIND)))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "m65x_real_insns_ok ()"
  "lda (%1,x)"
  [(set_attr "length" "2")])

(define_expand "storeqi_indy"
  [(set (mem:QI
	  (plus:HI (zero_extend:HI (match_operand:QI 0 "y_reg_operand" ""))
		   (match_operand:HI 1 "zp_reg_operand" "")))
	(match_operand:QI 2 "accumulator_operand" ""))]
  ""
  {})

(define_insn "storeqi_xind"
  [(set (mem:QI (unspec:QI [(match_operand:HI 0 "zp_reg_operand" "r")
			    (match_operand:QI 1 "x_reg_operand" "xq")]
			   UNSPEC_XIND))
	(match_operand:QI 2 "accumulator_operand" "Aq"))]
  "m65x_real_insns_ok ()"
  "sta (%0,x)"
  [(set_attr "length" "2")])

(define_insn "zp_clob_hardreg_movqi"
  [(set (match_operand:QI 0 "zp_reg_or_const_mem_operand" "=r,Uc, r,Uc")
	(match_operand:QI 1 "zp_reg_or_const_mem_operand"  "r, r,Uc,Uc"))
   (clobber (match_scratch:QI 2 "=hq,hq,hq,hq"))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "m65x_real_insns_ok ()"
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4,5,5,6")])

; Split ZP-reg load from absolute memory.

;(define_split
;  [(set (match_operand:QI 0 "zp_reg_operand" "")
;	(mem:QI (match_operand:HI 1 "immediate_operand" "")))
;   (clobber (reg:CC_NZ NZ_REGNUM))]
;  "reload_completed"
;  [(pc)]
;{
;  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
;  rtx par;
;
;  emit_insn (m65x_push (QImode, acc));
;  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
;  XVECEXP (par, 0, 0) = gen_rtx_SET (acc,
;				     gen_rtx_MEM (QImode, operands[1]));
;  XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
;					 gen_rtx_REG (CC_NZmode, NZ_REGNUM));
;  emit_insn (par);
;  m65x_emit_movqi_nz (operands[0], acc);
;  emit_insn (m65x_pop (QImode, acc));
;  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));
;
;  DONE;
;})

;(define_split
;  [(set (match_operand:QI 0 "zp_reg_operand" "")
;	(mem:QI (match_operand:HI 1 "immediate_operand" "")))]
;  "reload_completed"
;  [(pc)]
;{
;  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
;  rtx par;
;  rtx push_rtx = gen_rtx_MEM (CCmode,
;		    gen_rtx_POST_DEC (Pmode,
;				      gen_rtx_REG (Pmode, HARDSP_REGNUM)));
;  rtx pop_rtx = gen_rtx_MEM (CCmode,
;		    gen_rtx_PRE_INC (Pmode,
;				     gen_rtx_REG (Pmode, HARDSP_REGNUM)));
;
;  emit_insn (gen_pushflags (push_rtx));
;  emit_insn (m65x_push (QImode, acc));
;  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
;  XVECEXP (par, 0, 0) = gen_rtx_SET (acc,
;				     gen_rtx_MEM (QImode, operands[1]));
;  XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
;					 gen_rtx_REG (CC_NZmode, NZ_REGNUM));
;  emit_insn (par);
;  m65x_emit_movqi_nz (operands[0], acc);
;  emit_insn (m65x_pop (QImode, acc));
;  emit_insn (gen_popflags (pop_rtx));
;  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));
;
;  DONE;
;})

; Split ZP-reg store to absolute memory.

;(define_split
;  [(set (mem:QI (match_operand:HI 0 "immediate_operand" ""))
;	(match_operand:QI 1 "zp_reg_operand" ""))
;   (clobber (reg:CC_NZ NZ_REGNUM))]
;  "reload_completed"
;  [(pc)]
;{
;  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
;  rtx par;
;
;  emit_insn (m65x_push (QImode, acc));
;  m65x_emit_movqi_nz (acc, operands[1]);
;  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
;  XVECEXP (par, 0, 0) = gen_rtx_SET (gen_rtx_MEM (QImode, operands[0]), acc);
;  XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
;					 gen_rtx_REG (CC_NZmode, NZ_REGNUM));
;  emit_insn (par);
;  emit_insn (m65x_pop (QImode, acc));
;  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));
;
;  DONE;
;})

;(define_split
;  [(set (mem:QI (match_operand:HI 0 "immediate_operand" ""))
;	(match_operand:QI 1 "zp_reg_operand" ""))]
;  "reload_completed"
;  [(pc)]
;{
;  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
;  rtx par;
;  rtx push_rtx = gen_rtx_MEM (CCmode,
;		    gen_rtx_POST_DEC (Pmode,
;				      gen_rtx_REG (Pmode, HARDSP_REGNUM)));
;  rtx pop_rtx = gen_rtx_MEM (CCmode,
;		    gen_rtx_PRE_INC (Pmode,
;				     gen_rtx_REG (Pmode, HARDSP_REGNUM)));
;
;  emit_insn (gen_pushflags (push_rtx));
;  emit_insn (m65x_push (QImode, acc));
;  m65x_emit_movqi_nz (acc, operands[1]);
;  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
;  XVECEXP (par, 0, 0) = gen_rtx_SET (gen_rtx_MEM (QImode, operands[0]), acc);
;  XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
;					 gen_rtx_REG (CC_NZmode, NZ_REGNUM));
;  emit_insn (par);
;  emit_insn (m65x_pop (QImode, acc));
;  emit_insn (gen_popflags (pop_rtx));
;  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));
;
;  DONE;
;})

(define_expand "pushqi1"
  [(set (match_operand:QI 0 "hard_sp_operand"  "")
	(match_operand:QI 1 "hard_reg_operand" ""))]
  ""
{})

(define_expand "popqi1"
  [(set (match_operand:QI 0 "hard_reg_operand" "")
	(match_operand:QI 1 "hard_sp_operand"  ""))]
  ""
{})

(define_insn "pushflags"
  [(set (match_operand:CC 0 "hard_sp_operand" "=<")
	(unspec_volatile:CC [(reg:CC_NZ NZ_REGNUM)
			     (reg:CC_C CARRY_REGNUM)
			     (reg:CC_V OVERFLOW_REGNUM)] UNSPEC_FLAGS))]
  "m65x_real_insns_ok ()"
  "php"
  [(set_attr "length" "1")])

(define_insn "popflags"
  [(set (reg:CC_NZ NZ_REGNUM)
	(unspec_volatile:CC_NZ [(match_operand:CC 0 "hard_sp_operand" ">")]
			       UNSPEC_FLAGS_NZ))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec_volatile:CC_C [(const_int 0)] UNSPEC_FLAGS_C))
   (set (reg:CC_V OVERFLOW_REGNUM)
	(unspec_volatile:CC_V [(const_int 0)] UNSPEC_FLAGS_V))]
  "m65x_real_insns_ok ()"
  "plp"
  [(set_attr "length" "1")])

(define_expand "reload_inoutqi_zp"
  [(parallel [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
		   (match_operand:QI 1 "reload_zpreg_operand" "r"))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=hq"))])]
  ""
{
})

(define_insn "movqi_loadstore_zp"
  [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
	(match_operand:QI 1 "reload_zpreg_operand" "r"))
   (clobber (match_scratch:QI 2 "=hq"))]
  "m65x_real_insns_ok ()"
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4")])

; Increment/decrement instructions only affect N/Z, not carry or overflow.
; This is important when they are generated in the middle of multi-byte
; additions or subtractions! I.e. carry must not be marked as clobbered in the
; middle of such operations.

(define_subst "incdecqi3"
  [(set (match_operand:QI 0 "incdec_operand"
				  "=Aq,Aq,xq,xq,yq,yq,r,r,UX,UX,Uc,Uc,ZX,ZX")
	(plus:QI (match_operand:QI 1 "incdec_operand"
				   "%0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "one_or_minus_one_amount"
				    "K, L, K, L, K, L,K,L, K, L, K, L, K, L")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  [(set (match_dup 0) (plus:QI (match_dup 1) (match_dup 2)))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1) (match_dup 2)] UNSPEC_INCDEC_NZ))])

(define_subst_attr "incdecqi3_suf" "incdecqi3" "" "_nz")

(define_insn "incdecqi3<incdecqi3_suf>"
  [(set (match_operand:QI 0 "incdec_operand"
				  "=Aq,Aq,xq,xq,yq,yq,r,r,UX,UX,Uc,Uc,ZX,ZX")
	(plus:QI (match_operand:QI 1 "incdec_operand"
				   "%0, 0, 0, 0, 0, 0,0,0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "one_or_minus_one_amount"
				    "K, L, K, L, K, L,K,L, K, L, K, L, K, L")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "m65x_real_insns_ok ()"
  "@
  inc a
  dec a
  inx
  dex
  iny
  dey
  inc %0
  dec %0
  inc %0
  dec %0
  inc %0
  dec %0
  inc %0
  dec %0"
  [(set_attr "length" "1,1,1,1,1,1,2,2,3,3,3,3,2,2")
   (set_attr "arch" "cmos,cmos,*,*,*,*,*,*,*,*,*,*,*,*")])

(define_expand "addqi3"
  [(set (match_operand:QI 0 "incdec_operand" "")
	(plus:QI (match_operand:QI 1 "incdec_operand" "")
		 (match_operand:QI 2 "general_operand" "")))]
  ""
{})

(define_subst "addqi3_insn"
  [(set (match_operand:QI 0 "incdec_operand"
	     "=Aq,Aq,Aq,Aq,Aq,Aq,Aq,Aq,xq,yq,r,UX,Uc,ZX,Aq,xq,yq,r,UX,Uc,ZX")
	(plus:QI (match_operand:QI 1 "incdec_operand"
	      "%0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
	       "r,Uy,Ur,Uc,Uj, K, L,iS, K, K,K, K, K, K, M, L, L,L, L, L, L")))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  [(set (match_dup 0) (plus:QI (match_dup 1) (match_dup 2)))])

(define_subst_attr "addqi3_suf" "addqi3_insn" "" "_noclob")

(define_subst_attr "addqi3_length" "addqi3_insn"
  "3,3,3,4,4,1,1,1,3,1,1,2,3,3,2,3,1,1,2,3,3,2"
  "5,5,5,6,6,3,3,3,5,3,3,4,5,5,4,5,3,3,4,5,5,4")

(define_subst_attr "addqi3_saveflags" "addqi3_insn" "false" "true")
(define_subst_attr "addqi3_condition" "addqi3_insn" "reload_completed" "")

(define_insn "addqi3_insn<addqi3_suf>"
  [(set (match_operand:QI 0 "incdec_operand"
	  "=Aq,Aq,Aq,Aq,Aq,Aq,Aq,Aq,Aq,xq,yq,r,UX,Uc,ZX,Aq,xq,yq,r,UX,Uc,ZX")
	(plus:QI (match_operand:QI 1 "incdec_operand"
	   "%0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
	    "r,Uy,Ur,Uc,Uj,Aq, K, L,iS, K, K,K, K, K, K, M, L, L,L, L, L, L")))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  "<addqi3_condition>"
{
  const char *insns = NULL;

  switch (which_alternative)
    {
    case 0: insns = "clc\;adc %2"; break;
    case 1: insns = "clc\;adc %2"; break;
    case 2: insns = "clc\;adc %2"; break;
    case 3: insns = "clc\;adc %2"; break;
    case 4: insns = "clc\;adc %2"; break;
    case 5: insns = "asl a"; break;
    case 6: insns = "inc a"; break;
    case 7: insns = "dec a"; break;
    case 8: insns = "clc\;adc #%2"; break;
    case 9: insns = "inx"; break;
    case 10: insns = "iny"; break;
    case 11: insns = "inc %0"; break;
    case 12: insns = "inc %0"; break;
    case 13: insns = "inc %0"; break;
    case 14: insns = "inc %0"; break;
    case 15: insns = "sec\;sbc #%m2"; break;
    case 16: insns = "dex"; break;
    case 17: insns = "dey"; break;
    case 18: insns = "dec %0"; break;
    case 19: insns = "dec %0"; break;
    case 20: insns = "dec %0"; break;
    case 21: insns = "dec %0"; break;
    default: gcc_unreachable ();
    }

  if (<addqi3_saveflags>)
    {
      fprintf (asm_out_file, "\tphp\n");
      output_asm_insn (insns, operands);
      fprintf (asm_out_file, "\tplp\n");
    }
  else
    output_asm_insn (insns, operands);

  return "";
}
  [(set_attr "length" "<addqi3_length>")
   (set_attr "arch" "*,*,cmos,*,*,*,cmos,cmos,*,*,*,*,*,*,*,*,*,*,*,*,*,*")])

; Try to stick some clobbers in there...

;(define_peephole2
;  [(set (match_operand:QI 0 "incdec_operand" "")
;	(plus:QI (match_operand:QI 1 "incdec_operand" "")
;		 (match_operand:QI 2 "general_operand" "")))]
;  "peep2_regno_dead_p (1, NZ_REGNUM)
;   && peep2_regno_dead_p (1, CARRY_REGNUM)
;   && peep2_regno_dead_p (1, OVERFLOW_REGNUM)"
;  [(parallel [(set (match_dup 0) (plus:QI (match_dup 1) (match_dup 2)))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])])

(define_insn "subqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	    "=Aq,Aq,Aq,Aq")
	(minus:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0, 0")
		  (match_operand:QI 2 "nonimmediate_operand"  "r,Uy,Ur,Uc")))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  sec\;sbc %2
  sec\;sbc %2
  sec\;sbc %2
  sec\;sbc %2"
  [(set_attr "length" "3,3,3,4")
   (set_attr "arch" "*,*,cmos,*")])

(define_insn "clc"
  [(set (reg:CC_C CARRY_REGNUM) (unspec:CC_C [(const_int 0)] UNSPEC_CLC))]
  ""
  "clc"
  [(set_attr "length" "1")])

(define_insn "sec"
  [(set (reg:CC_C CARRY_REGNUM) (unspec:CC_C [(const_int 0)] UNSPEC_SEC))]
  ""
  "sec"
  [(set_attr "length" "1")])

(define_subst "adcqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	 "=Aq,Aq,Aq,Aq,Aq,Aq")
	(plus:QI
	  (plus:QI (match_operand:QI 1 "accumulator_operand"
							  "%0, 0, 0, 0, 0, 0")
		   (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj"))
	  (ne:QI (reg:CC_C CARRY_REGNUM) (const_int 0))))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  [(set (match_dup 0)
	(plus:QI (plus:QI (match_dup 1) (match_dup 2))
		 (ne:QI (reg:CC_C CARRY_REGNUM) (const_int 0))))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		     UNSPEC_ADC_C))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))])

(define_subst_attr "adcqi3_suf" "adcqi3" "" "_c")

; This can use rol for an "adc a" variant. Thanks Doz!

(define_insn "adcqi3<adcqi3_suf>"
  [(set (match_operand:QI 0 "accumulator_operand"	 "=Aq,Aq,Aq,Aq,Aq,Aq")
	(plus:QI
	  (plus:QI (match_operand:QI 1 "accumulator_operand"
							  "%0, 0, 0, 0, 0, 0")
		   (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj"))
	  (ne:QI (reg:CC_C CARRY_REGNUM) (const_int 0))))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  adc %2
  adc #%2
  adc %2
  adc %2
  adc %2
  adc %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_subst "sbcqi3"
  [(set (match_operand:QI 0 "accumulator_operand"        "=Aq,Aq,Aq,Aq,Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand"        "0, 0, 0, 0, 0, 0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj")
		    (eq:QI (reg:CC_C CARRY_REGNUM) (const_int 0)))))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  [(set (match_dup 0)
	(minus:QI (match_dup 1)
		  (minus:QI (match_dup 2)
			    (eq:QI (reg:CC_C CARRY_REGNUM) (const_int 0)))))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		     UNSPEC_SBC_C))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))])

(define_subst_attr "sbcqi3_suf" "sbcqi3" "" "_c")

(define_insn "sbcqi3<sbcqi3_suf>"
  [(set (match_operand:QI 0 "accumulator_operand"        "=Aq,Aq,Aq,Aq,Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand"        "0, 0, 0, 0, 0, 0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj")
		    (eq:QI (reg:CC_C CARRY_REGNUM) (const_int 0)))))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  sbc %2
  sbc #%2
  sbc %2
  sbc %2
  sbc %2
  sbc %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_insn "sbcqi3_nzv"
  [(set (match_operand:QI 0 "accumulator_operand"        "=Aq,Aq,Aq,Aq,Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand"        "0, 0, 0, 0, 0, 0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj")
		    (ltu:QI (reg:CC_C CARRY_REGNUM) (const_int 0)))))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		      UNSPEC_SBC_NZ))
   (set (reg:CC_V OVERFLOW_REGNUM)
	(unspec:CC_V [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		     UNSPEC_SBC_OVF))
   (clobber (reg:CC_C CARRY_REGNUM))]
  ""
  "@
  sbc %2
  sbc #%2
  sbc %2
  sbc %2
  sbc %2
  sbc %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_expand "negqi2"
  [(set (match_operand:QI 0 "register_operand" "")
	(neg:QI (match_operand:QI 1 "register_operand" "")))]
  ""
{
  rtx tmp = gen_reg_rtx (QImode);
  
  emit_insn (gen_xorqi3 (tmp, operands[1], gen_int_mode (0xff, QImode)));
  emit_insn (gen_addqi3 (operands[0], tmp, const1_rtx));
  
  DONE;
})

(define_insn "negate_highbit"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(xor:QI (match_operand:QI 1 "accumulator_operand" "0")
		(const_int 128)))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1)] UNSPEC_NEG_HIBIT))]
  ""
  "eor #$80\t; negate top bit"
  [(set_attr "length" "2")])

(define_expand "andqi3"
  [(parallel [(set (match_operand:QI 0 "qimode_ior_dst_operand" "")
		   (and:QI (match_operand:QI 1 "qimode_ior_dst_operand" "")
			   (match_operand:QI 2 "qimode_ior_src_operand" "")))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{
 /* if (m65x_real_insns_ok ())
    {*/
      if (can_create_pseudo_p () && TARGET_TRB_TSB
	  && zp_reg_or_const_mem_operand (operands[0], QImode)
	  && CONST_INT_P (operands[2]))
	{
	  /* This doesn't really work, it gets folded away into an andqi3 again
             (even when that means loading and storing the accumulator).  Maybe
	     setting RTX costs appropriately would help that.  */
	  rtx tmp = force_reg (QImode,
			       gen_int_mode (~INTVAL (operands[2]), QImode));
	  emit_insn (gen_m65x_trbqi3 (operands[0], tmp, operands[1]));
	  DONE;
	}
    /*}
  else
    {
      emit_insn (gen_andqi3_virt (operands[0], operands[1], operands[2]));
      DONE;
    }*/
})

(define_insn "andqi3_insn"
  [(set (match_operand:QI 0 "accumulator_operand"     "=Aq,Aq,Aq,Aq,Aq,Aq,Aq")
	(and:QI (match_operand:QI 1 "accumulator_operand"
						       "%0, 0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"
							"r, i,Uy,Ur,Uc,ZX,Uj")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  and %2
  and #%2
  and %2
  and %2
  and %2
  and %2
  and %2"
  [(set_attr "length" "2,2,2,2,3,2,3")
   (set_attr "arch" "*,*,*,cmos,*,*,*")])

(define_insn "m65x_trbqi3"
  [(set (match_operand:QI 0 "zp_reg_or_const_mem_operand"         "=r,Uc")
	(and:QI (not:QI (match_operand:QI 1 "accumulator_operand" "Aq,Aq"))
		(match_operand:QI 2 "zp_reg_or_const_mem_operand"  "0, 0")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "TARGET_TRB_TSB"
  "trb %0"
  [(set_attr "length" "2,3")
   (set_attr "arch" "cmos")])

(define_expand "iorqi3"
  [(parallel [(set (match_operand:QI 0 "qimode_ior_dst_operand" "")
		   (ior:QI (match_operand:QI 1 "qimode_ior_dst_operand" "")
			   (match_operand:QI 2 "qimode_ior_src_operand" "")))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{
  /*if (!m65x_real_insns_ok ())
    {
      emit_insn (gen_iorqi3_virt (operands[0], operands[1], operands[2]));
      DONE;
    }*/
})

(define_insn "iorqi3_insn"
  [(set (match_operand:QI 0 "qimode_ior_dst_operand"
					       "=Aq,Aq,Aq,Aq,Aq,Aq,Aq, r,Uc")
	(ior:QI (match_operand:QI 1 "qimode_ior_dst_operand"
						"%0, 0, 0, 0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_ior_src_operand"
						 "r, i,Uy,Ur,Uc,ZX,Uj,Aq,Aq")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  ora %2
  ora #%2
  ora %2
  ora %2
  ora %2
  ora %2
  ora %2
  tsb %0
  tsb %0"
  [(set_attr "length" "2,2,2,2,3,2,3,2,3")
   (set_attr "arch" "*,*,*,cmos,*,*,*,cmos,cmos")])

(define_insn "iorqi3_nz"
  [(set (match_operand:QI 0 "accumulator_operand"    "=Aq,Aq,Aq,Aq,Aq,Aq,Aq")
	(ior:QI (match_operand:QI 1 "accumulator_operand"
						      "%0, 0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"
						       "r, i,Uy,Ur,Uc,ZX,Uj")))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1) (match_dup 2)] UNSPEC_IOR_CC))]
  ""
  "@
  ora %2
  ora #%2
  ora %2
  ora %2
  ora %2
  ora %2
  ora %2"
  [(set_attr "length" "2,2,2,2,3,2,3")
   (set_attr "arch" "*,*,*,cmos,*,*,*")])

(define_expand "xorqi3"
  [(parallel [(set (match_operand:QI 0 "accumulator_operand" "")
		   (xor:QI (match_operand:QI 1 "accumulator_operand" "")
			   (match_operand:QI 2 "qimode_src_operand" "")))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{
  /*if (m65x_virt_insns_ok ())
    {
      emit_insn (gen_xorqi3_virt (operands[0], operands[1], operands[2]));
      DONE;
    }*/
})

(define_insn "xorqi3_insn"
  [(set (match_operand:QI 0 "accumulator_operand"    "=Aq,Aq,Aq,Aq,Aq,Aq,Aq")
	(xor:QI (match_operand:QI 1 "accumulator_operand"
						      "%0, 0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"
						       "r, i,Uy,Ur,Uc,ZX,Uj")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  eor %2
  eor #%2
  eor %2
  eor %2
  eor %2
  eor %2
  eor %2"
  [(set_attr "length" "2,2,2,2,3,2,3")
   (set_attr "arch" "*,*,*,cmos,*,*,*")])

(define_insn "loadqi_nz"
  [(set (match_operand:QI 0 "hard_reg_operand" "=&hq,hq,Aq,hq,hq,hq,hq")
	(match_operand:QI 1 "qimode_src_operand"  "r, i,Uy,Ur,Uc,Zj,Uj"))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1)] UNSPEC_LOAD_NZ))]
  ""
  "@
  ld%R0 %1
  ld%R0 #%1
  lda %1
  ld%R0 %1
  ld%R0 %1
  ld%R0 %1
  ld%R0 %1"
  [(set_attr "length" "2,2,2,2,3,2,3")
   (set_attr "arch" "*,*,*,cmos,*,*,*")])

(define_expand "ashlqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "")
	(ashift:QI (match_operand:QI 1 "reg_or_const_mem_operand" "")
		   (match_operand:QI 2 "shiftqi_amount" "")))]
  ""
{
  int i;
  rtx tmp;

  if (!CONST_INT_P (operands[2]))
    FAIL;

  switch (INTVAL (operands[2]))
    {
    case 1:
      emit_insn (gen_ashlqi3_insn (operands[0], operands[1], operands[2]));
      break;

    case 2:
    case 3:
    case 4:
    case 5:
      tmp = gen_reg_rtx (QImode);
      emit_move_insn (tmp, operands[1]);

      for (i = 0; i < INTVAL (operands[2]); i++)
        emit_insn (gen_ashlqi3_insn (tmp, tmp, const1_rtx));

      emit_move_insn (operands[0], tmp);
      break;

    case 6:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rorqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp,
			     gen_int_mode (0xc0, QImode)));
      break;

    case 7:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rorqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp,
			     gen_int_mode (0x80, QImode)));
      break;

    case 8:
      emit_move_insn (operands[0], const0_rtx);
      break;

    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "ashlqi3_insn"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"      "=Aq,r,Uc,ZX,UX")
	(ashift:QI (match_operand:QI 1 "reg_or_const_mem_operand"
							      "0,0, 0, 0, 0")
		   (match_operand:QI 2 "const_one_amount"     "K,K, K, K, K")))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2)] UNSPEC_ASL_C))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  asl a
  asl %0
  asl %0
  asl %0
  asl %0"
  [(set_attr "length" "1,2,3,2,3")])

(define_insn "m65x_rorqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"        "=Aq,r,Uc,ZX,UX")
	(unspec:QI [(match_operand:QI 1 "reg_or_const_mem_operand"
								"0,0, 0, 0, 0")
		    (reg:CC_C CARRY_REGNUM)]
		   UNSPEC_ROR))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (reg:CC_C CARRY_REGNUM)] UNSPEC_ROR))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  ror a
  ror %0
  ror %0
  ror %0
  ror %0"
  [(set_attr "length" "1,2,3,2,3")])

(define_insn "m65x_rolqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"        "=Aq,r,Uc,ZX,UX")
	(unspec:QI [(match_operand:QI 1 "reg_or_const_mem_operand"
								"0,0, 0, 0, 0")
		    (reg:CC_C CARRY_REGNUM)]
		   UNSPEC_ROL))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (reg:CC_C CARRY_REGNUM)] UNSPEC_ROL))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  rol a
  rol %0
  rol %0
  rol %0
  rol %0"
  [(set_attr "length" "1,2,3,2,3")])

(define_insn "rotlqi3"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
        (rotate:QI (match_operand:QI 1 "accumulator_operand" "0")
                   (match_operand:QI 2 "const_one_amount" "K")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "cmp #$80\;rol a"
  [(set_attr "length" "3")])

(define_expand "lshrqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "")
	(lshiftrt:QI (match_operand:QI 1 "reg_or_const_mem_operand" "")
		     (match_operand:QI 2 "shiftqi_amount" "")))]
  ""
{
  int i;
  rtx tmp;

  if (!CONST_INT_P (operands[2]))
    FAIL;

  switch (INTVAL (operands[2]))
    {
    case 1:
      emit_insn (gen_lshrqi3_insn (operands[0], operands[1], operands[2]));
      break;

    case 2:
    case 3:
    case 4:
    case 5:
      tmp = gen_reg_rtx (QImode);
      emit_move_insn (tmp, operands[1]);

      for (i = 0; i < INTVAL (operands[2]); i++)
        emit_insn (gen_lshrqi3_insn (tmp, tmp, const1_rtx));

      emit_move_insn (operands[0], tmp);
      break;

    case 6:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rolqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp,
			     gen_int_mode (0x03, QImode)));
      break;

    case 7:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rolqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp,
			     gen_int_mode (0x01, QImode)));
      break;

    case 8:
      emit_move_insn (operands[0], const0_rtx);
      break;

    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "lshrqi3_insn"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "=Aq,r,Uc,ZX,UX")
	(lshiftrt:QI
	  (match_operand:QI 1 "reg_or_const_mem_operand" "0,0, 0, 0, 0")
	  (match_operand:QI 2 "const_one_amount"	 "K,K, K, K, K")))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2)] UNSPEC_LSR_C))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  lsr a
  lsr %0
  lsr %0
  lsr %0
  lsr %0"
  [(set_attr "length" "1,2,3,2,3")])

(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	       "=Aq")
	(ashiftrt:QI (match_operand:QI 1 "accumulator_operand"  "0")
		     (match_operand:QI 2 "shiftqi_amount"       "NB")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "cmp #$80\;ror a";
    case 2: return "cmp #$80\;ror a\;cmp #$80\;ror a";
    case 3: return "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
    case 4: return "lsr a\;lsr a\;lsr a\;lsr a\;cmp #8\;bcc :+\;ora #$f0\;:";
    case 5: return "lsr a\;lsr a\;lsr a\;lsr a\;lsr a\;cmp #4\;bcc :+\;"
		   "ora #$f8\;:";
    case 6: return "rol a\;rol a\;rol a\;and #3\;cmp #2\;bcc :+\;ora #$fc\;:";
    case 7:
    case 8: return "ora #$7f\;bmi :+\;lda #0\;:";
    default: gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(match_test "INTVAL (operands[2]) == 1") (const_int 3)
	       (match_test "INTVAL (operands[2]) == 2") (const_int 6)
	       (match_test "INTVAL (operands[2]) == 3") (const_int 9)
	       (match_test "INTVAL (operands[2]) == 4") (const_int 10)
	       (match_test "INTVAL (operands[2]) == 5") (const_int 11)
	       (match_test "INTVAL (operands[2]) == 6") (const_int 11)
	       (match_test "INTVAL (operands[2]) == 7") (const_int 6)
	       (match_test "INTVAL (operands[2]) == 8") (const_int 6)]
	      (const_int 0)))])

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Aq")
	(not:QI (match_operand:QI 1 "accumulator_operand"   "0")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "eor #$ff"
  [(set_attr "length" "2")])

; Comparisons.

(define_insn "compareqi"
  [(set (reg:CC_C CARRY_REGNUM)
	(compare:CC_C (match_operand:QI 0 "hard_reg_operand"
						      "hq,hq,hq,Aq,Aq,Aq,Aq")
		      (match_operand:QI 1 "compareqi_src_operand"
						       "r, i,Uc,Uy,Ur,ZX,Uj")))
   (set (reg:CC_NZ NZ_REGNUM)
	(compare:CC_NZ (match_dup 0) (match_dup 1)))]
  ""
  "@
  %C0 %1
  %C0 #%1
  %C0 %1
  %C0 %1
  %C0 %1
  %C0 %1
  %C0 %1"
  [(set_attr "length" "2,2,3,2,2,2,3")
   (set_attr "arch" "*,*,*,*,cmos,*,*")])

; Jumps & calls.

(define_mode_iterator CBRQI [CC_C CC_UI CC_V CC_NZ])
(define_mode_attr signedness [(CC_C "c") (CC_UI "ui") (CC_NZ "nz") (CC_V "v")])
; Warning: symbolic names don't work here! These must be kept in sync with
; register numbers in 6502.h.
;(define_mode_attr ccmode_reg [(CC_C { 72 }) (CC_UI { 72 })
;                              (CC_V { 76 }) (CC_NZ { 68 })])

(define_insn "condbranchqi_cc_c"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_c_comparison"
			[(reg:CC_C CARRY_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (CC_Cmode, operands[0], operands[1],
		     get_attr_length (insn) > 2);
  return "";
}
  [(set (attr "length")
	(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -110))
			   (lt (minus (match_dup 1) (pc)) (const_int 110)))
		      (const_int 2)
		      (const_int 5)))])

(define_insn "condbranchqi_cc_ui"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_ui_comparison"
			[(reg:CC_UI CARRY_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (CC_UImode, operands[0], operands[1],
		     get_attr_length (insn) > 2);
  return "";
}
  [(set (attr "length")
	(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -110))
			   (lt (minus (match_dup 1) (pc)) (const_int 110)))
		      (const_int 2)
		      (const_int 5)))])

(define_insn "condbranchqi_cc_nz"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_nz_comparison"
			[(reg:CC_NZ NZ_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (CC_NZmode, operands[0], operands[1],
		     get_attr_length (insn) > 2);
  return "";
}
  [(set (attr "length")
	(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -110))
			   (lt (minus (match_dup 1) (pc)) (const_int 110)))
		      (const_int 2)
		      (const_int 5)))])

(define_insn "condbranchqi_cc_v"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_v_comparison"
			[(reg:CC_V OVERFLOW_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (CC_Vmode, operands[0], operands[1],
		     get_attr_length (insn) > 2);
  return "";
}
  [(set (attr "length")
	(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -110))
			   (lt (minus (match_dup 1) (pc)) (const_int 110)))
		      (const_int 2)
		      (const_int 5)))])

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "zp_reg_operand" "r"))]
  ""
  "jmp (%0)"
  [(set_attr "length" "2")])

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0"
  [(set_attr "length" "3")])

(define_expand "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "m65x_comparison"
		 [(match_operand:QI 1 "register_operand"	"")
		  (match_operand:QI 2 "nonmemory_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  ""
{
  switch (GET_CODE (operands[0]))
    {
    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      m65x_emit_qimode_comparison (GET_CODE (operands[0]), operands[1],
				   operands[2], operands[3]);
      break;

    case LEU:
      m65x_emit_qimode_comparison (GEU, operands[2], operands[1], operands[3]);
      break;

    case GTU:
      m65x_emit_qimode_comparison (LTU, operands[2], operands[1], operands[3]);
      break;

    case LE:
      m65x_emit_qimode_comparison (GE, operands[2], operands[1], operands[3]);
      break;

    case GT:
      m65x_emit_qimode_comparison (LT, operands[2], operands[1], operands[3]);
      break;
    
    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use (const_int 0))])])

(define_insn "call_sym"
  [(call (mem:QI (match_operand:HI 0 "" ""))
  	 (match_operand 1 "" ""))
   (use (const_int 0))]
  "GET_CODE (operands[0]) == SYMBOL_REF"
  "jsr %0"
  [(set_attr "length" "3")])

(define_insn "call_indirect"
  [(call (mem:QI (match_operand:HI 0 "register_operand" "r"))
	 (match_operand 1 "" ""))
   (use (const_int 0))]
  ""
{
  output_asm_insn ("lda #>(_call_ind$%=-1)\;"
		   "pha\;"
		   "lda #<(_call_ind$%=-1)\;"
		   "pha\;"
		   "jmp (%0)\;"
		   "_call_ind$%=:", operands);
  return "";
}
  [(set_attr "length" "9")])

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
        	   (call (match_operand 1 "memory_operand" "")
  			 (match_operand 2 "general_operand" "")))
	      (use (const_int 0))])])

(define_insn "call_value_sym"
  [(set (match_operand 0 "" "")
        (call (mem:QI (match_operand:HI 1 "" ""))
  	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  "GET_CODE (operands[1]) == SYMBOL_REF"
  "jsr %1"
  [(set_attr "length" "3")])

(define_insn "call_indirect_sym"
  [(set (match_operand 0 "" "")
	(call (mem:QI (match_operand:HI 1 "zp_reg_operand" "r"))
	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  ""
{
  output_asm_insn ("lda #>(_call_ind$%=-1)\;"
		   "pha\;"
		   "lda #<(_call_ind$%=-1)\;"
		   "pha\;"
		   "jmp (%1)\;"
		   "_call_ind$%=:", operands);
  return "";
}
  [(set_attr "length" "9")])

(define_insn "m65x_return"
  [(return)]
  ""
  "rts"
  [(set_attr "length" "1")])

(define_expand "prologue"
  [(pc)]
  ""
{
  m65x_expand_prologue ();
  DONE;
})

(define_expand "epilogue"
  [(pc)]
  ""
{
  m65x_expand_epilogue ();
  DONE;
})

(define_insn "m65x_savestack_s7s0_sp"
  [(unspec_volatile [(match_operand 0 "x_reg_operand" "xq")
		     (match_operand 1 "y_reg_operand" "yq")]
		    UNSPECV_SAVESTACK_S7S0_SP)]
  "m65x_real_insns_ok ()"
  "jsr __m65x_savestack_s7s0_sp"
  [(set_attr "length" "3")])

(define_insn "m65x_savestack_s7s0"
  [(unspec_volatile [(const_int 0)] UNSPECV_SAVESTACK_S7S0)]
  "m65x_real_insns_ok ()"
  "jsr __m65x_savestack_s7s0"
  [(set_attr "length" "3")])

(define_insn "m65x_restorestack_s7s0_sp_rts"
  [(unspec_volatile [(const_int 0)] UNSPECV_RESTORESTACK_S7S0_SP_RTS)
   (return)]
  "m65x_real_insns_ok ()"
  "jmp __m65x_restorestack_s7s0_sp_rts"
  [(set_attr "length" "3")])

(define_insn "m65x_restorestack_s7s0_rts"
  [(unspec_volatile [(const_int 0)] UNSPECV_RESTORESTACK_S7S0_RTS)
   (return)]
  "m65x_real_insns_ok ()"
  "jmp __m65x_restorestack_s7s0_rts"
  [(set_attr "length" "3")])

(include "6502-virt.md")
